"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useCombobox_unstable", {
    enumerable: true,
    get: function() {
        return useCombobox_unstable;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactfield = require("@fluentui/react-field");
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _reacticons = require("@fluentui/react-icons");
const _reactutilities = require("@fluentui/react-utilities");
const _dropdownKeyActions = require("../../utils/dropdownKeyActions");
const _useComboboxBaseState = require("../../utils/useComboboxBaseState");
const _useComboboxPositioning = require("../../utils/useComboboxPositioning");
const _useTriggerListboxSlots = require("../../utils/useTriggerListboxSlots");
const _Listbox = require("../Listbox/Listbox");
const useCombobox_unstable = (props, ref)=>{
    var _props_input;
    // Merge props from surrounding <Field>, if any
    props = (0, _reactfield.useFieldControlProps_unstable)(props, {
        supportsLabelFor: true,
        supportsRequired: true,
        supportsSize: true
    });
    const baseState = (0, _useComboboxBaseState.useComboboxBaseState)({
        ...props,
        editable: true
    });
    const { activeOption, clearSelection, getIndexOfId, getOptionsMatchingText, hasFocus, open, selectOption, selectedOptions, setActiveOption, setFocusVisible, setOpen, setValue, value } = baseState;
    const [comboboxPopupRef, comboboxTargetRef] = (0, _useComboboxPositioning.useComboboxPositioning)(props);
    const { disabled, freeform, inlinePopup, multiselect } = props;
    const comboId = (0, _reactutilities.useId)('combobox-');
    const { primary: triggerNativeProps, root: rootNativeProps } = (0, _reactutilities.getPartitionedNativeProps)({
        props,
        primarySlotTagName: 'input',
        excludedPropNames: [
            'children',
            'size'
        ]
    });
    const rootRef = _react.useRef(null);
    const triggerRef = _react.useRef(null);
    // NVDA and JAWS have bugs that suppress reading the input value text when aria-activedescendant is set
    // To prevent this, we clear the HTML attribute (but save the state) when a user presses left/right arrows
    // ref: https://github.com/microsoft/fluentui/issues/26359#issuecomment-1397759888
    const [hideActiveDescendant, setHideActiveDescendant] = _react.useState(false);
    // save the typing vs. navigating options state, as the space key should behave differently in each case
    // we do not want to update the combobox when this changes, just save the value between renders
    const isTyping = _react.useRef(false);
    // set active option and selection based on typing
    const getOptionFromInput = (inputValue)=>{
        const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
        if (!searchString || searchString.length === 0) {
            return;
        }
        const matcher = (optionText)=>optionText.toLowerCase().indexOf(searchString) === 0;
        const matches = getOptionsMatchingText(matcher);
        // return first matching option after the current active option, looping back to the top
        if (matches.length > 1 && activeOption) {
            const startIndex = getIndexOfId(activeOption.id);
            const nextMatch = matches.find((option)=>getIndexOfId(option.id) >= startIndex);
            return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
        }
        var _matches_;
        return (_matches_ = matches[0]) !== null && _matches_ !== void 0 ? _matches_ : undefined;
    };
    /* Handle typed input */ // reset any typed value when an option is selected
    baseState.selectOption = (ev, option)=>{
        setValue(undefined);
        selectOption(ev, option);
    };
    const onTriggerBlur = (ev)=>{
        // handle selection and updating value if freeform is false
        if (!baseState.open && !freeform) {
            // select matching option, if the value fully matches
            if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) {
                baseState.selectOption(ev, activeOption);
            }
            // reset typed value when the input loses focus while collapsed, unless freeform is true
            setValue(undefined);
        }
    };
    baseState.setOpen = (ev, newState)=>{
        if (disabled) {
            return;
        }
        if (!newState && !freeform) {
            setValue(undefined);
        }
        setOpen(ev, newState);
    };
    // update value and active option based on input
    const onTriggerChange = (ev)=>{
        const inputValue = ev.target.value;
        // update uncontrolled value
        baseState.setValue(inputValue);
        // handle updating active option based on input
        const matchingOption = getOptionFromInput(inputValue);
        setActiveOption(matchingOption);
        setFocusVisible(true);
        // clear selection for single-select if the input value no longer matches the selection
        if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) {
            clearSelection(ev);
        }
    };
    // resolve input and listbox slot props
    let triggerSlot;
    let listboxSlot;
    triggerSlot = _reactutilities.slot.always(props.input, {
        defaultProps: {
            ref: (0, _reactutilities.useMergedRefs)((_props_input = props.input) === null || _props_input === void 0 ? void 0 : _props_input.ref, triggerRef),
            type: 'text',
            value: value !== null && value !== void 0 ? value : '',
            ...triggerNativeProps
        },
        elementType: 'input'
    });
    const resolvedPropsOnKeyDown = triggerSlot.onKeyDown;
    triggerSlot.onChange = (0, _reactutilities.mergeCallbacks)(triggerSlot.onChange, onTriggerChange);
    triggerSlot.onBlur = (0, _reactutilities.mergeCallbacks)(triggerSlot.onBlur, onTriggerBlur); // only resolve listbox slot if needed
    listboxSlot = open || hasFocus ? _reactutilities.slot.optional(props.listbox, {
        renderByDefault: true,
        defaultProps: {
            children: props.children
        },
        elementType: _Listbox.Listbox
    }) : undefined;
    [triggerSlot, listboxSlot] = (0, _useTriggerListboxSlots.useTriggerListboxSlots)(props, baseState, ref, triggerSlot, listboxSlot);
    const listboxRef = (0, _reactutilities.useMergedRefs)(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, comboboxPopupRef);
    if (hideActiveDescendant) {
        triggerSlot['aria-activedescendant'] = undefined;
    }
    if (listboxSlot) {
        listboxSlot.ref = listboxRef;
    }
    const rootSlot = _reactutilities.slot.always(props.root, {
        defaultProps: {
            'aria-owns': !inlinePopup ? listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id : undefined,
            ...rootNativeProps
        },
        elementType: 'div'
    });
    rootSlot.ref = (0, _reactutilities.useMergedRefs)(rootSlot.ref, comboboxTargetRef);
    const state = {
        components: {
            root: 'div',
            input: 'input',
            expandIcon: 'span',
            listbox: _Listbox.Listbox
        },
        root: rootSlot,
        input: triggerSlot,
        listbox: listboxSlot,
        expandIcon: _reactutilities.slot.optional(props.expandIcon, {
            renderByDefault: true,
            defaultProps: {
                'aria-expanded': open,
                children: /*#__PURE__*/ _react.createElement(_reacticons.ChevronDownRegular, null),
                role: 'button'
            },
            elementType: 'span'
        }),
        ...baseState
    };
    state.root.ref = (0, _reactutilities.useMergedRefs)(state.root.ref, rootRef);
    /* Set input.onKeyDown here, so we can override the default behavior for spacebar */ const defaultOnTriggerKeyDown = state.input.onKeyDown;
    state.input.onKeyDown = (0, _reactutilities.useEventCallback)((ev)=>{
        if (!open && (0, _dropdownKeyActions.getDropdownActionFromKey)(ev) === 'Type') {
            baseState.setOpen(ev, true);
        }
        // clear activedescendant when moving the text insertion cursor
        if (ev.key === _keyboardkeys.ArrowLeft || ev.key === _keyboardkeys.ArrowRight) {
            setHideActiveDescendant(true);
        } else {
            setHideActiveDescendant(false);
        }
        // update typing state to true if the user is typing
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(ev, {
            open,
            multiselect
        });
        if (action === 'Type') {
            isTyping.current = true;
        } else if (action === 'Open' && ev.key !== ' ' || action === 'Next' || action === 'Previous' || action === 'First' || action === 'Last' || action === 'PageUp' || action === 'PageDown') {
            isTyping.current = false;
        }
        // allow space to insert a character if freeform & the last action was typing, or if the popup is closed
        if (freeform && (isTyping.current || !open) && ev.key === ' ') {
            resolvedPropsOnKeyDown === null || resolvedPropsOnKeyDown === void 0 ? void 0 : resolvedPropsOnKeyDown(ev);
            return;
        }
        // if we're not allowing space to type, continue with default behavior
        defaultOnTriggerKeyDown === null || defaultOnTriggerKeyDown === void 0 ? void 0 : defaultOnTriggerKeyDown(ev);
    });
    /* handle open/close + focus change when clicking expandIcon */ const { onMouseDown: onIconMouseDown, onClick: onIconClick } = state.expandIcon || {};
    const onExpandIconMouseDown = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(onIconMouseDown, ()=>{
        // do not dismiss on blur when closing via clicking the icon
        if (open) {
            baseState.ignoreNextBlur.current = true;
        }
    }));
    const onExpandIconClick = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(onIconClick, (event)=>{
        var _triggerRef_current;
        // open and set focus
        state.setOpen(event, !state.open);
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
        // set focus visible=false, since this can only be done with the mouse/pointer
        setFocusVisible(false);
    }));
    if (state.expandIcon) {
        state.expandIcon.onMouseDown = onExpandIconMouseDown;
        state.expandIcon.onClick = onExpandIconClick;
        // If there is no explicit aria-label, calculate default accName attribute for expandIcon button,
        // using the following steps:
        // 1. If there is an aria-label, it is "Open [aria-label]"
        // 2. If there is an aria-labelledby, it is "Open [aria-labelledby target]" (using aria-labelledby + ids)
        // 3. If there is no aria-label/ledby attr, it falls back to "Open"
        // We can't fall back to a label/htmlFor name because of https://github.com/w3c/accname/issues/179
        const hasExpandLabel = state.expandIcon['aria-label'] || state.expandIcon['aria-labelledby'];
        const defaultOpenString = 'Open'; // this is english-only since it is the fallback
        if (!hasExpandLabel) {
            if (props['aria-labelledby']) {
                var _state_expandIcon_id;
                const chevronId = (_state_expandIcon_id = state.expandIcon.id) !== null && _state_expandIcon_id !== void 0 ? _state_expandIcon_id : `${comboId}-chevron`;
                const chevronLabelledBy = `${chevronId} ${state.input['aria-labelledby']}`;
                state.expandIcon['aria-label'] = defaultOpenString;
                state.expandIcon.id = chevronId;
                state.expandIcon['aria-labelledby'] = chevronLabelledBy;
            } else if (props['aria-label']) {
                state.expandIcon['aria-label'] = `${defaultOpenString} ${props['aria-label']}`;
            } else {
                state.expandIcon['aria-label'] = defaultOpenString;
            }
        }
    }
    return state;
};
