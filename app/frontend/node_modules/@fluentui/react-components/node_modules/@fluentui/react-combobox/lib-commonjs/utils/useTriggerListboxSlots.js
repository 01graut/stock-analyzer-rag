"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTriggerListboxSlots", {
    enumerable: true,
    get: function() {
        return useTriggerListboxSlots;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _reactutilities = require("@fluentui/react-utilities");
const _dropdownKeyActions = require("../utils/dropdownKeyActions");
function useTriggerListboxSlots(props, state, ref, triggerSlot, listboxSlot) {
    const { multiselect } = props;
    const { activeOption, getCount, getIndexOfId, getOptionAtIndex, ignoreNextBlur, open, selectOption, setActiveOption, setFocusVisible, setHasFocus, setOpen } = state;
    // handle trigger focus/blur
    const triggerRef = _react.useRef(null);
    const listboxRef = _react.useRef(null);
    // resolve listbox shorthand props
    const listboxId = (0, _reactutilities.useId)('fluent-listbox', listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.id);
    const mergedListboxRef = (0, _reactutilities.useMergedRefs)(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, listboxRef);
    const listbox = listboxSlot && {
        id: listboxId,
        multiselect,
        tabIndex: undefined,
        ...listboxSlot,
        ref: mergedListboxRef
    };
    // resolve trigger shorthand props
    const trigger = {
        'aria-expanded': open,
        'aria-activedescendant': open ? activeOption === null || activeOption === void 0 ? void 0 : activeOption.id : undefined,
        role: 'combobox',
        ...triggerSlot,
        // explicitly type the ref as an intersection here to prevent type errors
        // since the `children` prop has mutually incompatible types between input/button
        // functionally both ref and triggerRef will always be the same element type
        ref: (0, _reactutilities.useMergedRefs)(ref, triggerSlot === null || triggerSlot === void 0 ? void 0 : triggerSlot.ref, triggerRef)
    };
    /*
   * Handle focus when clicking the listbox popup:
   * 1. Move focus back to the button/input when the listbox is clicked (otherwise it goes to body)
   * 2. Do not close the listbox on button/input blur when clicking into the listbox
   */ const listboxOnClick = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)((event)=>{
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onClick));
    const listboxOnMouseOver = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)((event)=>{
        setFocusVisible(false);
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseOver));
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    const documentOnMouseUp = (0, _reactutilities.useEventCallback)((ev)=>{
        var _listboxRef_current;
        if (!((_listboxRef_current = listboxRef.current) === null || _listboxRef_current === void 0 ? void 0 : _listboxRef_current.contains(ev.target))) {
            setOpen(ev, false);
        }
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('mouseup', documentOnMouseUp);
    });
    const listboxOnMouseDown = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)((event)=>{
        ignoreNextBlur.current = true;
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('mouseup', documentOnMouseUp);
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseDown));
    const listboxOnMouseUp = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)((event)=>{
        // some listbox clicks don't blur the input (e.g. clicking a scrollbar)
        // this ensures future blurs that occur after the click aren't ignored
        ignoreNextBlur.current = false;
    }, listbox === null || listbox === void 0 ? void 0 : listbox.onMouseUp));
    // listbox is nullable, only add event handlers if it exists
    if (listbox) {
        listbox.onClick = listboxOnClick;
        listbox.onMouseOver = listboxOnMouseOver;
        listbox.onMouseDown = listboxOnMouseDown;
        listbox.onMouseUp = listboxOnMouseUp;
    }
    // the trigger should open/close the popup on click or blur
    trigger.onBlur = (0, _reactutilities.mergeCallbacks)((event)=>{
        if (!ignoreNextBlur.current) {
            setOpen(event, false);
        }
        ignoreNextBlur.current = false;
        setHasFocus(false);
    }, trigger.onBlur);
    trigger.onClick = (0, _reactutilities.mergeCallbacks)((event)=>{
        setOpen(event, !open);
    }, trigger.onClick);
    trigger.onFocus = (0, _reactutilities.mergeCallbacks)((event)=>{
        setHasFocus(true);
    }, trigger.onFocus);
    // handle combobox keyboard interaction
    trigger.onKeyDown = (0, _reactutilities.mergeCallbacks)((event)=>{
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(event, {
            open,
            multiselect
        });
        const maxIndex = getCount() - 1;
        const activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
        let newIndex = activeIndex;
        switch(action){
            case 'Open':
                event.preventDefault();
                setFocusVisible(true);
                setOpen(event, true);
                break;
            case 'Close':
                // stop propagation for escape key to avoid dismissing any parent popups
                event.stopPropagation();
                event.preventDefault();
                setOpen(event, false);
                break;
            case 'CloseSelect':
                !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(event, false);
            // fallthrough
            case 'Select':
                activeOption && selectOption(event, activeOption);
                event.preventDefault();
                break;
            case 'Tab':
                !multiselect && activeOption && selectOption(event, activeOption);
                break;
            default:
                newIndex = (0, _dropdownKeyActions.getIndexFromAction)(action, activeIndex, maxIndex);
        }
        if (newIndex !== activeIndex) {
            // prevent default page scroll/keyboard action if the index changed
            event.preventDefault();
            setActiveOption(getOptionAtIndex(newIndex));
            setFocusVisible(true);
        }
    }, trigger.onKeyDown);
    trigger.onMouseOver = (0, _reactutilities.mergeCallbacks)((event)=>{
        setFocusVisible(false);
    }, trigger.onMouseOver);
    return [
        trigger,
        listbox
    ];
}
